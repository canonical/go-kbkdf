// Copyright 2021 Canonical Ltd.
// Licensed under the LGPLv3 with static-linking exception.
// See LICENCE file for details.

package main

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"
	"unicode"
)

const prologue = `
// Copyright 2021 Canonical Ltd.
// Licensed under the LGPLv3 with static-linking exception.
// See LICENCE file for details.

// This file is autogenerated with testdata/gentest.go

package kbkdf_test

import (
	_ "crypto/sha1"
	_ "crypto/sha256"
	_ "crypto/sha512"
	"encoding/hex"
	"testing"

	. "github.com/canonical/go-kbkdf"
	"github.com/canonical/go-kbkdf/hmac_prf"

	. "gopkg.in/check.v1"
)

func Test(t *testing.T) { TestingT(t) }

func decodeHexString(c *C, s string) []byte {
	x, err := hex.DecodeString(s)
	c.Assert(err, IsNil)
	return x
}

type kdfSuite struct{}

var _ = Suite(&kdfSuite{})

type testData struct {
	key       []byte
	fixed     []byte
	iv        []byte
	bitLength uint32
	expected  []byte
}

func (s *kdfSuite) testCounterMode(c *C, prf PRF, data *testData) {
	c.Check(CounterModeKeyInternal(prf, data.key, data.fixed, data.bitLength), DeepEquals, data.expected)
}

func (s *kdfSuite) testFeedbackMode(c *C, prf PRF, data *testData, iterationCounterMode IterationCounterMode) {
	c.Check(FeedbackModeKeyInternal(prf, data.key, data.fixed, data.iv, data.bitLength, iterationCounterMode), DeepEquals, data.expected)
}

func (s *kdfSuite) testPipelineMode(c *C, prf PRF, data *testData, iterationCounterMode IterationCounterMode) {
	c.Check(PipelineModeKeyInternal(prf, data.key, data.fixed, data.bitLength, iterationCounterMode), DeepEquals, data.expected)
}`

var (
	newlineToken    = []byte{'\n'}
	whitespaceToken = []byte{}

	prfs = map[string]string{
		"HMAC_SHA1":   "hmac_prf.SHA1",
		"HMAC_SHA224": "hmac_prf.SHA224",
		"HMAC_SHA256": "hmac_prf.SHA256",
		"HMAC_SHA384": "hmac_prf.SHA384",
		"HMAC_SHA512": "hmac_prf.SHA512",
	}
)

func isNewlineToken(tok string) bool {
	return tok == string(newlineToken)
}

func isWhitespaceToken(tok string) bool {
	return tok == string(whitespaceToken)
}

type testCase map[string]string

type testSuite struct {
	name   string
	params map[string]string
	tests  []testCase
}

type stateFunc func(string) (stateFunc, error)

type parser struct {
	scanner *bufio.Scanner
	current stateFunc

	suites       []*testSuite
	currentSuite *testSuite
	currentTest  testCase
	currentName  string

	expectingNewline bool
	expectingValue   bool
}

func (p *parser) scanFn() func([]byte, bool) (int, []byte, error) {
	return func(data []byte, atEOF bool) (int, []byte, error) {
		// Scan until the end of the line
		lineAdv, tok, err := bufio.ScanLines(data, atEOF)
		switch {
		case err != nil:
			return 0, nil, err
		case lineAdv == 0:
			// The data doesn't contain a carriage return and there's
			// more data to come, so request it.
			return 0, nil, nil
		case len(tok) == 0 && p.expectingNewline:
			// We've got to the end of a line that we've just processed,
			// so advance over the newline and return a newline token.
			return lineAdv, newlineToken, nil
		case len(tok) == 0 && p.expectingValue:
			// We've encountered an empty value. Return a whitespace token
			// and we'll advance past the newline on the next scan iteration.
			return 0, whitespaceToken, nil
		case len(tok) == 0:
			// We've encountered an empty line, so advance past it,
			// returning a whitespace token.
			return lineAdv, whitespaceToken, nil
		}

		// Advance to the first non-space character.
		adv := strings.IndexFunc(string(tok), func(r rune) bool {
			return !unicode.IsSpace(r)
		})
		switch {
		case adv < 0 && p.expectingValue:
			// We've encountered a value that is all whitespace. Advance
			// over everything except for the newline, which will
			// happen on the next scan iteration.
			return lineAdv - 1, whitespaceToken, nil
		case adv < 0:
			// The rest of the line is all space. Advance over
			// it and return a whitespace token.
			return lineAdv, whitespaceToken, nil
		}
		tok = tok[adv:]

		// The entire the line is a comment - request a new one.
		if tok[0] == '#' {
			return lineAdv, nil, nil
		}

		// Find the next delimiter.
		i := strings.IndexAny(string(tok), "[]=")
		switch {
		case i == 0:
			// We have a delimiter token
			tok = []byte{tok[0]}
		case i >= 0:
			// We have a string token
			tok = tok[:i]
		}

		// Advance over the entire token, including any whitespace (which
		// we'll strip from the return).
		adv += len(tok)

		// There shouldn't be any leading space because of the earlier
		// advance, but trim any trailing space from the returned token.
		tok = []byte(strings.TrimSpace(string(tok)))

		return adv, tok, nil
	}
}

func (p *parser) startTestSuite(tok string) (stateFunc, error) {
	switch {
	case isWhitespaceToken(tok):
		// Nothing to process on this iteration
		return p.startTestSuite, nil
	case tok == "[":
		// Open a new suite.
		p.currentSuite = &testSuite{params: make(map[string]string)}
		p.suites = append(p.suites, p.currentSuite)
		return p.handleTestSuiteName, nil
	default:
		return nil, fmt.Errorf("startTestSuite: unexpected token %q", tok)
	}
}

func (p *parser) handleTestSuiteName(tok string) (stateFunc, error) {
	switch {
	case tok == "[" || tok == "]" || tok == "=":
		return nil, fmt.Errorf("handleTestSuiteName: unexpected token %q", tok)
	default:
		p.currentName = tok
		return p.handleEndTestSuiteName, nil
	}
}

func (p *parser) handleEndTestSuiteName(tok string) (stateFunc, error) {
	switch {
	case p.currentSuite == nil:
		panic("no current suite")
	case tok == "]":
		// This test suite has an explicit name.
		p.currentSuite.name = p.currentName
		return p.newSwallowNewline(p.handleTestSuiteParam), nil
	case tok == "=":
		// This test suite doesn't have an explicit name - we're dealing with
		// a test suite parameter.
		return p.newHandleEqual(p.commitTestSuiteParam)(tok)
	default:
		return nil, fmt.Errorf("handleEndTestSuiteName: unexpected token %q", tok)
	}
}

func (p *parser) handleTestSuiteParam(tok string) (stateFunc, error) {
	switch {
	case isWhitespaceToken(tok):
		// We've finished parsing the test suite parameters.
		return p.startTestCase, nil
	case tok == "[":
		// We've got another test suite parameter.
		return p.newHandleParam(p.commitTestSuiteParam), nil
	case tok == "]" || tok == "=":
		return nil, fmt.Errorf("handleTestSuiteParam: unexpected token %q", tok)
	default:
		// We're starting a test case.
		return p.startTestCase(tok)
	}
}

func (p *parser) commitTestSuiteParam(value string) (stateFunc, error) {
	if p.currentSuite == nil {
		panic("no current suite")
	}
	if p.currentSuite.name == "" {
		// If the test suite doesn't have an explicit name, use the
		// value of the first parameter.
		p.currentSuite.name = value
	}
	p.currentSuite.params[p.currentName] = value
	return p.handleEndTestSuiteParam, nil
}

func (p *parser) handleEndTestSuiteParam(tok string) (stateFunc, error) {
	switch {
	case tok == "]":
		return p.newSwallowNewline(p.handleTestSuiteParam), nil
	default:
		return nil, fmt.Errorf("handleEndTestSuiteParam: unexpected token %q", tok)
	}
}

func (p *parser) startTestCase(tok string) (stateFunc, error) {
	switch {
	case isWhitespaceToken(tok):
		// Nothing to process on this iteration
		return p.startTestCase, nil
	case tok == "[":
		p.currentSuite = nil
		return p.startTestSuite(tok)
	default:
		if p.currentSuite == nil {
			panic("no current suite")
		}
		p.currentTest = make(testCase)
		return p.handleTestCaseParam(tok)
	}
}

func (p *parser) handleTestCaseParam(tok string) (stateFunc, error) {
	if p.currentSuite == nil {
		panic("no current suite")
	}
	if p.currentTest == nil {
		panic("no current test")
	}
	switch {
	case isWhitespaceToken(tok):
		// This is the end of the test case.
		p.currentSuite.tests = append(p.currentSuite.tests, p.currentTest)
		p.currentTest = nil
		return p.startTestCase, nil
	default:
		return p.newHandleParam(p.commitTestCaseParam)(tok)
	}
}

func (p *parser) commitTestCaseParam(value string) (stateFunc, error) {
	if p.currentTest == nil {
		panic("no current test")
	}
	p.currentTest[p.currentName] = value
	return p.newSwallowNewline(p.handleTestCaseParam), nil
}

func (p *parser) newHandleParam(commit stateFunc) stateFunc {
	return func(tok string) (stateFunc, error) {
		switch {
		case tok == "[" || tok == "]" || tok == "=":
			return nil, fmt.Errorf("handleParam: unexpected token in name: %q", tok)
		default:
			p.currentName = tok
			return p.newHandleEqual(commit), nil
		}
	}
}

func (p *parser) newHandleEqual(commit stateFunc) stateFunc {
	return func(tok string) (stateFunc, error) {
		switch {
		case tok == "=":
			return p.newHandleParamValue(commit), nil
		default:
			return nil, fmt.Errorf("handleEqual: unexpected token %q", tok)
		}
	}
}

func (p *parser) newHandleParamValue(commit stateFunc) stateFunc {
	p.expectingValue = true
	return func(tok string) (stateFunc, error) {
		defer func() {
			p.expectingValue = false
		}()
		switch {
		case tok == "[" || tok == "]" || tok == "=":
			return nil, fmt.Errorf("handleParamValue: unexpected token: %q", tok)
		default:
			return commit(tok)
		}
	}
}

func (p *parser) newSwallowNewline(next stateFunc) stateFunc {
	p.expectingNewline = true
	return func(tok string) (stateFunc, error) {
		defer func() {
			p.expectingNewline = false
		}()
		switch {
		case isNewlineToken(tok):
			return next, nil
		default:
			return nil, fmt.Errorf("handleNewline: unexpected token: %q", tok)
		}
	}
}

func (p *parser) run() error {
	for p.scanner.Scan() {
		next, err := p.current(p.scanner.Text())
		if err != nil {
			return err
		}
		p.current = next
	}
	return p.scanner.Err()
}

func newParser(r io.Reader) *parser {
	scanner := bufio.NewScanner(r)
	p := &parser{scanner: scanner}
	scanner.Split(p.scanFn())
	p.current = p.startTestSuite
	return p
}

var errSkipSuite = errors.New("")

func generateTests(vectors string, filter map[string]string, emitSuite func(*testSuite, int) error, emitTest func(*testSuite, int, int, testCase) error) error {
	f, err := os.Open(vectors)
	if err != nil {
		return err
	}
	defer f.Close()

	parser := newParser(f)
	if err := parser.run(); err != nil {
		return err
	}

	for i, suite := range parser.suites {
		skip := false
		for k, v := range filter {
			if suite.params[k] != v {
				skip = true
				break
			}
		}

		if skip {
			continue
		}

		if err := emitSuite(suite, i); err != nil {
			if err == errSkipSuite {
				continue
			}
			return err
		}

		for j, test := range suite.tests {
			if err := emitTest(suite, i, j, test); err != nil {
				return err
			}
		}
	}

	return nil
}

type atomicFile struct {
	*os.File
	path string
}

func (f *atomicFile) Commit() error {
	return os.Rename(f.Name(), f.path)
}

func (f *atomicFile) Close() error {
	os.Remove(f.Name())
	return f.File.Close()
}

func newAtomicFile(path string) (*atomicFile, error) {
	f, err := ioutil.TempFile("", "gentest")
	if err != nil {
		return nil, fmt.Errorf("cannot create temporary file: %v", err)
	}
	return &atomicFile{f, path}, nil
}

func run(out io.Writer) error {
	if err := generateTests("testdata/CounterMode/KDFCTR_gen.rsp", map[string]string{"CTRLOCATION": "BEFORE_FIXED", "RLEN": "32_BITS"},
		func(suite *testSuite, _ int) error {
			newPrf, ok := prfs[suite.params["PRF"]]
			if !ok {
				return errSkipSuite
			}

			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) testCounterMode%[1]s(c *C, data *testData) {
	s.testCounterMode(c, %[2]s, data)
}`,
				suite.params["PRF"], newPrf)
			return err
		},
		func(suite *testSuite, _, i int, test testCase) error {
			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) TestCounterMode%[1]s_%[2]d(c *C) {
	s.testCounterMode%[1]s(c, &testData{
		key: decodeHexString(c, "%[3]s"),
		fixed: decodeHexString(c, "%[4]s"),
		bitLength: %[5]s,
		expected: decodeHexString(c, "%[6]s"),
	})
}`,
				suite.params["PRF"], i, test["KI"], test["FixedInputData"], test["L"], test["KO"])
			return err
		},
	); err != nil {
		return err
	}

	if err := generateTests("testdata/FeedbackModenocounter/KDFFeedback_gen.rsp", nil,
		func(suite *testSuite, _ int) error {
			newPrf, ok := prfs[suite.params["PRF"]]
			if !ok {
				return errSkipSuite
			}

			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) testFeedbackModeNoCounter%[1]s(c *C, data *testData) {
	s.testFeedbackMode(c, %[2]s, data, OmitIterationCounter)
}`,
				suite.params["PRF"], newPrf)
			return err
		},
		func(suite *testSuite, _, i int, test testCase) error {
			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) TestFeedbackModeNoCounter%[1]s_%[2]d(c *C) {
	s.testFeedbackModeNoCounter%[1]s(c, &testData{
		key: decodeHexString(c, "%[3]s"),
		fixed: decodeHexString(c, "%[4]s"),
		iv: decodeHexString(c, "%[5]s"),
		bitLength: %[6]s,
		expected: decodeHexString(c, "%[7]s"),
	})
}`,
				suite.params["PRF"], i, test["KI"], test["FixedInputData"], test["IV"], test["L"], test["KO"])
			return err
		},
	); err != nil {
		return err
	}

	if err := generateTests("testdata/FeedbackModeNOzeroiv/KDFFeedback_gen.rsp", map[string]string{"CTRLOCATION": "AFTER_ITER", "RLEN": "32_BITS"},
		func(suite *testSuite, _ int) error {
			newPrf, ok := prfs[suite.params["PRF"]]
			if !ok {
				return errSkipSuite
			}

			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) testFeedbackModeNoZeroIV%[1]s(c *C, data *testData) {
	s.testFeedbackMode(c, %[2]s, data, IncludeIterationCounter)
}`,
				suite.params["PRF"], newPrf)
			return err
		},
		func(suite *testSuite, _, i int, test testCase) error {
			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) TestFeedbackModeNoZeroIV%[1]s_%[2]d(c *C) {
	s.testFeedbackModeNoZeroIV%[1]s(c, &testData{
		key: decodeHexString(c, "%[3]s"),
		fixed: decodeHexString(c, "%[4]s"),
		iv: decodeHexString(c, "%[5]s"),
		bitLength: %[6]s,
		expected: decodeHexString(c, "%[7]s"),
	})
}`,
				suite.params["PRF"], i, test["KI"], test["FixedInputData"], test["IV"], test["L"], test["KO"])
			return err
		},
	); err != nil {
		return err
	}

	if err := generateTests("testdata/FeedbackModewzeroiv/KDFFeedback_gen.rsp", map[string]string{"CTRLOCATION": "AFTER_ITER", "RLEN": "32_BITS"},
		func(suite *testSuite, _ int) error {
			newPrf, ok := prfs[suite.params["PRF"]]
			if !ok {
				return errSkipSuite
			}

			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) testFeedbackModeZeroIV%[1]s(c *C, data *testData) {
	s.testFeedbackMode(c, %[2]s, data, IncludeIterationCounter)
}`,
				suite.params["PRF"], newPrf)
			return err
		},
		func(suite *testSuite, _, i int, test testCase) error {
			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) TestFeedbackModeZeroIV%[1]s_%[2]d(c *C) {
	s.testFeedbackModeZeroIV%[1]s(c, &testData{
		key: decodeHexString(c, "%[3]s"),
		fixed: decodeHexString(c, "%[4]s"),
		iv: decodeHexString(c, "%[5]s"),
		bitLength: %[6]s,
		expected: decodeHexString(c, "%[7]s"),
	})
}`,
				suite.params["PRF"], i, test["KI"], test["FixedInputData"], test["IV"], test["L"], test["KO"])
			return err
		},
	); err != nil {
		return err
	}

	if err := generateTests("testdata/PipelineModewithCounter/KDFDblPipeline_gen.rsp", map[string]string{"CTRLOCATION": "AFTER_ITER", "RLEN": "32_BITS"},
		func(suite *testSuite, _ int) error {
			newPrf, ok := prfs[suite.params["PRF"]]
			if !ok {
				return errSkipSuite
			}

			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) testPipelineMode%[1]s(c *C, data *testData) {
	s.testPipelineMode(c, %[2]s, data, IncludeIterationCounter)
}`,
				suite.params["PRF"], newPrf)
			return err
		},
		func(suite *testSuite, _, i int, test testCase) error {
			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) TestPipelineMode%[1]s_%[2]d(c *C) {
	s.testPipelineMode%[1]s(c, &testData{
		key: decodeHexString(c, "%[3]s"),
		fixed: decodeHexString(c, "%[4]s"),
		bitLength: %[5]s,
		expected: decodeHexString(c, "%[6]s"),
	})
}`,
				suite.params["PRF"], i, test["KI"], test["FixedInputData"], test["L"], test["KO"])
			return err
		},
	); err != nil {
		return err
	}

	if err := generateTests("testdata/PipelineModeWOCounterr/KDFDblPipeline_gen.rsp", nil,
		func(suite *testSuite, _ int) error {
			newPrf, ok := prfs[suite.params["PRF"]]
			if !ok {
				return errSkipSuite
			}

			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) testPipelineModeNoCounter%[1]s(c *C, data *testData) {
	s.testPipelineMode(c, %[2]s, data, OmitIterationCounter)
}`,
				suite.params["PRF"], newPrf)
			return err
		},
		func(suite *testSuite, _, i int, test testCase) error {
			_, err := fmt.Fprintf(out, `

func (s *kdfSuite) TestPipelineModeNoCounter%[1]s_%[2]d(c *C) {
	s.testPipelineModeNoCounter%[1]s(c, &testData{
		key: decodeHexString(c, "%[3]s"),
		fixed: decodeHexString(c, "%[4]s"),
		bitLength: %[5]s,
		expected: decodeHexString(c, "%[6]s"),
	})
}`,
				suite.params["PRF"], i, test["KI"], test["FixedInputData"], test["L"], test["KO"])
			return err
		},
	); err != nil {
		return err
	}

	return nil
}

func main() {
	dst, err := newAtomicFile("kdf_test.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Cannot open destination file: %v\n")
		os.Exit(1)
	}

	if _, err := io.WriteString(dst, prologue); err != nil {
		fmt.Fprintf(os.Stderr, "Cannot write proogue: %v\n", err)
		dst.Close()
		os.Exit(1)
	}

	if err := run(dst); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		dst.Close()
		os.Exit(1)
	}

	if err := dst.Commit(); err != nil {
		fmt.Fprintf(os.Stderr, "Cannot commit destination file: %v\n")
		dst.Close()
		os.Exit(1)
	}

	dst.Close()
}
